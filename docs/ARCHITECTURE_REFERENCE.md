# æ¶æ„å‚è€ƒï¼šæ ¹å› åˆ†æç³»ç»ŸäºŒæœŸè®¾è®¡å¯¹ xctl çš„å¯å‘

## ğŸ“Š æ¶æ„å¯¹æ¯”åˆ†æ

### å½“å‰ xctl æ¶æ„ vs æ ¹å› åˆ†æç³»ç»ŸäºŒæœŸ

| ç»´åº¦ | xctl (å½“å‰) | æ ¹å› åˆ†æç³»ç»ŸäºŒæœŸ | å‚è€ƒä»·å€¼ |
|------|------------|-----------------|---------|
| **æ•°æ®æº** | äº‹ä»¶æµï¼ˆGPU/ç½‘ç»œ/å­˜å‚¨æ¢é’ˆï¼‰ | K8s Events + ELK Logs + PodçŠ¶æ€ | â­â­â­ å¤šæºæ•°æ®èåˆ |
| **åœºæ™¯åˆ†æ** | é€šç”¨å› æœå›¾ï¼ˆWaitsOn/BlockedByï¼‰ | 11ä¸ªå…·ä½“åœºæ™¯ï¼ˆContainerCreatingç­‰ï¼‰ | â­â­â­â­ åœºæ™¯åŒ–åˆ†æ |
| **çŸ¥è¯†ç®¡ç†** | æ— ï¼ˆæ¯æ¬¡è°ƒç”¨å¤§æ¨¡å‹ï¼‰ | ä¸“å®¶åº“+æ¡ˆä¾‹åº“+æ¨¡å¼åº“ | â­â­â­â­â­ çŸ¥è¯†æ²‰æ·€ |
| **å¤„ç†è¿½è¸ª** | æ—  | æ–¹æ¡ˆç”Ÿæˆ+æ‰§è¡Œ+éªŒè¯ | â­â­â­â­ é—­ç¯ç®¡ç† |
| **é‡åŒ–æŒ‡æ ‡** | æ—  | æŒ‡æ ‡æ”¶é›†+æŠ¥è¡¨ç”Ÿæˆ | â­â­â­ æ•°æ®åŒ–æ”¯æ’‘ |

## ğŸ¯ æ ¸å¿ƒå‚è€ƒç‚¹

### 1. è§„åˆ™å¼•æ“ï¼ˆå£°æ˜å¼çŸ¥è¯†åº“ï¼‰â­ å·²ä¿®æ­£

**æ¶æ„å¸ˆé¢„è­¦**ï¼šâŒ ä¸è¦å¼•å…¥ SQLiteï¼Œä¼šç ´å Daemon çš„ stateless å’Œæç®€åŸåˆ™ã€‚

**ä¿®æ­£æ–¹æ¡ˆ**ï¼šä½¿ç”¨å£°æ˜å¼ YAML/TOML è§„åˆ™æ–‡ä»¶ã€‚

**è®¾è®¡**ï¼š
- è§„åˆ™æ–‡ä»¶æ”¾åœ¨ `rules/` ç›®å½•ï¼ˆå¦‚ `rules/gpu-oom.yaml`ï¼‰
- Daemon å¯åŠ¨æ—¶åŠ è½½è§„åˆ™åˆ°å†…å­˜
- æ— æ•°æ®åº“ä¾èµ–ï¼Œæ—  I/O å¼€é”€
- æ˜“äºç‰ˆæœ¬æ§åˆ¶å’Œåä½œ

**å®æ–½å»ºè®®**ï¼š
1. å®ç° YAML è§„åˆ™æ–‡ä»¶æ ¼å¼
2. å®ç°è§„åˆ™åŒ¹é…å¼•æ“ï¼ˆå†…å­˜åŒ¹é…ï¼‰
3. åœ¨ `diag.rs` ä¸­ä¼˜å…ˆåŒ¹é…è§„åˆ™ï¼Œæœªå‘½ä¸­å†è°ƒç”¨å¤§æ¨¡å‹
4. å¤æ‚åœºæ™¯çš„çŸ¥è¯†åº“åŒ¹é…æ”¾åœ¨ CLI ç«¯ï¼Œè°ƒç”¨è¿œç«¯å‘é‡æ•°æ®åº“

è¯¦è§ [RULES_ENGINE.md](RULES_ENGINE.md)

### 2. åœºæ™¯åŒ–åˆ†æï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰

**å½“å‰é—®é¢˜**ï¼š
- `xctl why` æ˜¯é€šç”¨çš„é€†å‘ DFSï¼Œä¸å¤Ÿç²¾å‡†
- æ— æ³•é’ˆå¯¹ç‰¹å®šåœºæ™¯ä¼˜åŒ–åˆ†æé€»è¾‘

**å‚è€ƒæ–¹æ¡ˆ**ï¼š
```rust
// å»ºè®®åœ¨ src/scene/ æ¨¡å—å®ç°
pub enum SceneType {
    // GPU ç›¸å…³
    GpuOom,              // GPU OOM
    GpuUtilLow,          // GPU åˆ©ç”¨ç‡ä½
    GpuError,            // GPU ç¡¬ä»¶é”™è¯¯
    
    // ç½‘ç»œç›¸å…³
    NetworkStall,        // ç½‘ç»œé˜»å¡
    NetworkDrop,         // ç½‘ç»œä¸¢åŒ…
    
    // å­˜å‚¨ç›¸å…³
    StorageIoError,      // å­˜å‚¨ IO é”™è¯¯
    StorageSlow,         // å­˜å‚¨æ…¢
    
    // è¿›ç¨‹ç›¸å…³
    ProcessBlocked,      // è¿›ç¨‹é˜»å¡
    ProcessCrash,        // è¿›ç¨‹å´©æºƒ
}

pub trait SceneAnalyzer {
    fn analyze(&self, graph: &StateGraph, target: &str) -> AnalysisResult;
}
```

**å®æ–½å»ºè®®**ï¼š
1. ä¸ºæ¯ä¸ªåœºæ™¯å®ç°ä¸“é—¨çš„åˆ†æå™¨
2. åœºæ™¯è‡ªåŠ¨è¯†åˆ«ï¼ˆåŸºäºäº‹ä»¶ç±»å‹å’ŒçŠ¶æ€ï¼‰
3. åœºæ™¯ç‰¹å®šçš„æ ¹å› æ¨å¯¼é€»è¾‘

### 3. å¤„ç†è¿½è¸ªç³»ç»Ÿï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰

**å½“å‰é—®é¢˜**ï¼š
- `xctl diag` åªæä¾›å»ºè®®ï¼Œæ— æ³•è¿½è¸ªæ‰§è¡Œæ•ˆæœ
- æ— æ³•éªŒè¯é—®é¢˜æ˜¯å¦çœŸæ­£è§£å†³

**å‚è€ƒæ–¹æ¡ˆ**ï¼š
```rust
// å»ºè®®åœ¨ src/tracking/ æ¨¡å—å®ç°
pub struct SolutionPlan {
    analysis_id: String,
    knowledge_id: Option<String>,
    plan_type: PlanType,  // auto/manual/hybrid
    solution_steps: Vec<SolutionStep>,
    status: PlanStatus,
}

pub struct SolutionExecution {
    plan_id: String,
    step_number: u32,
    execution_status: ExecutionStatus,
    execution_result: serde_json::Value,
}

pub struct SolutionVerification {
    plan_id: String,
    verification_result: VerificationResult,
    metrics_before: serde_json::Value,
    metrics_after: serde_json::Value,
    recurrence_status: RecurrenceStatus,
}
```

**å®æ–½å»ºè®®**ï¼š
1. æ–°å¢ `xctl fix <pid>` å‘½ä»¤ï¼šç”Ÿæˆå¹¶æ‰§è¡Œä¿®å¤æ–¹æ¡ˆ
2. æ–°å¢ `xctl verify <plan_id>` å‘½ä»¤ï¼šéªŒè¯ä¿®å¤æ•ˆæœ
3. è‡ªåŠ¨å®šæœŸå¤æŸ¥ï¼Œæ£€æµ‹é—®é¢˜æ˜¯å¦å¤å‘

### 4. Prometheus Exporterï¼ˆæŒ‡æ ‡å¯¼å‡ºï¼‰â­ å·²ä¿®æ­£

**æ¶æ„å¸ˆé¢„è­¦**ï¼šâŒ ä¸è¦é€ è½®å­ï¼Œä¸è¦æˆä¸º Prometheus çš„åŠ£è´¨æ›¿ä»£å“ã€‚

**ä¿®æ­£æ–¹æ¡ˆ**ï¼šå®ç° Prometheus Exporterï¼Œæ ‡å‡†åŒ–å¯¼å‡ºæŒ‡æ ‡ã€‚

**è®¾è®¡**ï¼š
- xctl æš´éœ² `/metrics` ç«¯ç‚¹ï¼ˆPrometheus æ ¼å¼ï¼‰
- åªå¯¼å‡ºäº‹ä»¶å’Œå› æœå…³ç³»ç›¸å…³æŒ‡æ ‡
- ä¸å­˜å‚¨å†å²æ•°æ®ï¼Œä¸ç”ŸæˆæŠ¥è¡¨
- æŠ¥è¡¨äº¤ç»™ Grafanaï¼Œxctl åªè´Ÿè´£å®æ—¶æµ

**å¯¼å‡ºçš„æŒ‡æ ‡**ï¼š
- äº‹ä»¶è®¡æ•°ï¼ˆæŒ‰ç±»å‹ï¼‰
- å› æœå…³ç³»æŒ‡æ ‡ï¼ˆWaitsOn/BlockedBy/Consumes è¾¹æ•°é‡ï¼‰
- è¯Šæ–­æŒ‡æ ‡ï¼ˆè¯Šæ–­æ¬¡æ•°ã€å»¶è¿Ÿã€åœºæ™¯åˆ†å¸ƒï¼‰
- å›¾çŠ¶æ€æŒ‡æ ‡ï¼ˆæ´»è·ƒè¿›ç¨‹æ•°ã€èµ„æºæ•°ã€é”™è¯¯èŠ‚ç‚¹æ•°ï¼‰

**å®æ–½å»ºè®®**ï¼š
1. ä½¿ç”¨ `prometheus` crate å®ç°æŒ‡æ ‡å¯¼å‡º
2. æ–°å¢ `--metrics-port` å‚æ•°ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸å¯ç”¨ï¼‰
3. ä¸ç°æœ‰ Prometheus ç”Ÿæ€æ— ç¼é›†æˆ

è¯¦è§ [METRICS_EXPORT.md](METRICS_EXPORT.md)

### 5. å¤šæºæ•°æ®é›†æˆï¼ˆä½ä¼˜å…ˆçº§ï¼Œä½†å¾ˆæœ‰ä»·å€¼ï¼‰

**å½“å‰é—®é¢˜**ï¼š
- åªä¾èµ–æ¢é’ˆäº‹ä»¶ï¼Œæ•°æ®æºå•ä¸€
- æ— æ³•å…³è”ç³»ç»Ÿæ—¥å¿—ã€K8s äº‹ä»¶ç­‰

**å‚è€ƒæ–¹æ¡ˆ**ï¼š
è™½ç„¶ xctl ä¸“æ³¨äº AI åŸºç¡€è®¾æ–½ï¼ˆé K8sï¼‰ï¼Œä½†å¯ä»¥å€Ÿé‰´æ€è·¯ï¼š
1. æ”¯æŒä» Prometheus æŸ¥è¯¢æŒ‡æ ‡
2. æ”¯æŒä»æ—¥å¿—ç³»ç»Ÿï¼ˆå¦‚ ELKï¼‰æŸ¥è¯¢ç›¸å…³æ—¥å¿—
3. äº‹ä»¶å…³è”ï¼šå°†æ¢é’ˆäº‹ä»¶ä¸å¤–éƒ¨æ•°æ®æºå…³è”

## ğŸš€ å®æ–½è·¯çº¿å›¾

### Phase 1: eBPF ç½‘ç»œæ¢é’ˆï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼Œ4-6å‘¨ï¼‰

**Week 1-2: eBPF ç¨‹åºå¼€å‘**
- ç¼–å†™ eBPF ç¨‹åºï¼ˆç›‘æ§ TCP/RDMA é‡ä¼ å’Œå»¶è¿Ÿï¼‰
- ä½¿ç”¨ BCC æˆ– Rust Aya æ¡†æ¶
- æµ‹è¯• eBPF ç¨‹åºåœ¨å†…æ ¸ä¸­çš„è¿è¡Œ

**Week 3-4: ç”¨æˆ·ç©ºé—´ç¨‹åº**
- å®ç° eBPF map è¯»å–
- äº‹ä»¶è½¬æ¢ä¸º xctl Event æ ¼å¼
- é›†æˆåˆ° SubprocessProbe æˆ–ç›´æ¥é›†æˆ

**Week 5-6: æµ‹è¯•å’Œä¼˜åŒ–**
- æ€§èƒ½æµ‹è¯•
- ç¨³å®šæ€§æµ‹è¯•
- æ–‡æ¡£å®Œå–„

### Phase 2: è§„åˆ™å¼•æ“ï¼ˆ3å‘¨ï¼‰

**Week 1: è§„åˆ™æ–‡ä»¶æ ¼å¼**
- è®¾è®¡ YAML è§„åˆ™æ–‡ä»¶æ ¼å¼
- å®ç°è§„åˆ™è§£æå™¨

**Week 2: è§„åˆ™åŒ¹é…å¼•æ“**
- å®ç°æ¡ä»¶åŒ¹é…é€»è¾‘
- å®ç°è§„åˆ™ä¼˜å…ˆçº§æ’åº

**Week 3: é›†æˆåˆ°è¯Šæ–­æµç¨‹**
- ä¿®æ”¹ `diag.rs`ï¼Œä¼˜å…ˆåŒ¹é…è§„åˆ™
- æœªå‘½ä¸­å†è°ƒç”¨å¤§æ¨¡å‹
- æµ‹è¯•å’Œä¼˜åŒ–

### Phase 3: åœºæ™¯åŒ–åˆ†æï¼ˆ2å‘¨ï¼‰

**Week 1: æ ¸å¿ƒåœºæ™¯å®ç°**
- å®ç° GPU OOM åœºæ™¯åˆ†æå™¨
- å®ç°ç½‘ç»œé˜»å¡åœºæ™¯åˆ†æå™¨
- å®ç°è¿›ç¨‹å´©æºƒåœºæ™¯åˆ†æå™¨

**Week 2: åœºæ™¯è‡ªåŠ¨è¯†åˆ«**
- å®ç°åœºæ™¯è¯†åˆ«é€»è¾‘
- é›†æˆåˆ° `xctl why` å‘½ä»¤
- æµ‹è¯•å’Œä¼˜åŒ–

### Phase 4: å¤„ç†è¿½è¸ªï¼ˆ2å‘¨ï¼‰

**Week 1: æ–¹æ¡ˆç”Ÿæˆå’Œæ‰§è¡Œ**
- å®ç° `SolutionPlan` æ•°æ®æ¨¡å‹
- æ–°å¢ `xctl fix` å‘½ä»¤
- å®ç°æ–¹æ¡ˆæ‰§è¡Œè®°å½•

**Week 2: æ•ˆæœéªŒè¯**
- å®ç°è‡ªåŠ¨éªŒè¯é€»è¾‘
- å®ç°å®šæœŸå¤æŸ¥æœºåˆ¶
- æ–°å¢ `xctl verify` å‘½ä»¤

### Phase 5: Prometheus Exporterï¼ˆ1å‘¨ï¼‰

**Week 1: æŒ‡æ ‡å¯¼å‡º**
- å®ç° Prometheus æŒ‡æ ‡å¯¼å‡º
- æ·»åŠ  `--metrics-port` å‚æ•°
- ä¸ Grafana é›†æˆæµ‹è¯•

## ğŸ’¡ å…³é”®æŠ€æœ¯ç‚¹

### 1. eBPF ç½‘ç»œæ¢é’ˆå®ç°

```c
// network_probe.bpf.c
SEC("kprobe/tcp_retransmit_skb")
int trace_tcp_retransmit(struct pt_regs *ctx) {
    struct network_event event = {};
    event.pid = bpf_get_current_pid_tgid() >> 32;
    event.event_type = NETWORK_RETRANSMIT;
    event.timestamp = bpf_ktime_get_ns();
    
    bpf_ringbuf_output(&events, &event, sizeof(event), 0);
    return 0;
}
```

### 2. è§„åˆ™åŒ¹é…ç®—æ³•

```rust
// è§„åˆ™æ¡ä»¶åŒ¹é…
fn match_rule(rule: &Rule, events: &[Event], graph: &StateGraph) -> bool {
    rule.conditions.iter().all(|condition| {
        match condition {
            Condition::Event { event_type, value_pattern, .. } => {
                events.iter().any(|e| {
                    e.event_type.to_string() == *event_type &&
                    value_pattern.as_ref().map_or(true, |p| e.value.contains(p))
                })
            }
            Condition::Graph { edge_type, .. } => {
                // æ£€æŸ¥å›¾ä¸­æ˜¯å¦å­˜åœ¨æŒ‡å®šç±»å‹çš„è¾¹
                graph.has_edge_type(edge_type)
            }
        }
    })
}
```

### 2. åœºæ™¯è¯†åˆ«

```rust
fn identify_scene(graph: &StateGraph, pid: u32) -> Option<SceneType> {
    // æ£€æŸ¥ GPU ç›¸å…³äº‹ä»¶
    if has_gpu_error(graph, pid) {
        return Some(SceneType::GpuError);
    }
    
    // æ£€æŸ¥ç½‘ç»œé˜»å¡
    if has_network_stall(graph, pid) {
        return Some(SceneType::NetworkStall);
    }
    
    // æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
    if is_process_crashed(graph, pid) {
        return Some(SceneType::ProcessCrash);
    }
    
    None
}
```

### 3. æ•ˆæœéªŒè¯ç­–ç•¥

```rust
async fn verify_solution(plan_id: &str) -> VerificationResult {
    // 1. è·å–ä¿®å¤å‰çš„æŒ‡æ ‡
    let metrics_before = collect_metrics_before(plan_id).await;
    
    // 2. ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼ˆå¦‚ 5 åˆ†é’Ÿï¼‰
    tokio::time::sleep(Duration::from_secs(300)).await;
    
    // 3. è·å–ä¿®å¤åçš„æŒ‡æ ‡
    let metrics_after = collect_metrics_after(plan_id).await;
    
    // 4. å¯¹æ¯”åˆ†æ
    if metrics_after.problem_resolved(&metrics_before) {
        VerificationResult::Resolved
    } else if metrics_after.partially_improved(&metrics_before) {
        VerificationResult::Partial
    } else {
        VerificationResult::Failed
    }
}
```

## ğŸ“ˆ é¢„æœŸæ”¶ç›Šï¼ˆä¿®æ­£ç‰ˆï¼‰

### çŸ­æœŸæ”¶ç›Šï¼ˆ1-2ä¸ªæœˆï¼‰

1. **æ ¸å¿ƒèƒ½åŠ›**ï¼šeBPF æ¢é’ˆå®ç°ï¼Œxctl å…·å¤‡çœŸæ­£çš„é™ç»´æ‰“å‡»èƒ½åŠ›
2. **æˆæœ¬é™ä½**ï¼šè§„åˆ™å¼•æ“å‘½ä¸­ç‡ 30%+ï¼Œå‡å°‘å¤§æ¨¡å‹è°ƒç”¨
3. **å‡†ç¡®ç‡æå‡**ï¼šåœºæ™¯åŒ–åˆ†æï¼Œæ ¹å› è¯†åˆ«å‡†ç¡®ç‡æå‡ 20%+

### é•¿æœŸæ”¶ç›Šï¼ˆ3-6ä¸ªæœˆï¼‰

1. **çŸ¥è¯†æ²‰æ·€**ï¼šè§„åˆ™æ–‡ä»¶å½¢æˆå¯å¤ç”¨çš„çŸ¥è¯†åº“
2. **é—­ç¯ç®¡ç†**ï¼šè¿½è¸ªå¤„ç†æ•ˆæœï¼ŒéªŒè¯æ ¹æ²»æƒ…å†µ
3. **ç”Ÿæ€é›†æˆ**ï¼šä¸ Prometheus/Grafana æ— ç¼é›†æˆ

## ğŸ”„ æ¶æ„æ¼”è¿›å»ºè®®ï¼ˆä¿®æ­£ç‰ˆï¼‰

### ä¿æŒ xctl çš„æ ¸å¿ƒä¼˜åŠ¿

1. **KISS åŸåˆ™**ï¼šè§„åˆ™å¼•æ“ä½¿ç”¨ YAML æ–‡ä»¶ï¼Œä¸å¼•å…¥æ•°æ®åº“
2. **Stateless**ï¼šDaemon ä¿æŒæ— çŠ¶æ€ï¼Œé‡å¯åé‡æ–°åŠ è½½è§„åˆ™
3. **äº‹ä»¶é©±åŠ¨**ï¼šä¿æŒäº‹ä»¶æµæ¶æ„ï¼Œè§„åˆ™å¼•æ“ä½œä¸ºå¢å¼ºå±‚
4. **æ¢é’ˆè§£è€¦**ï¼šä¿æŒæ¢é’ˆç‹¬ç«‹æ€§ï¼Œä¸æ±¡æŸ“æ ¸å¿ƒ

### æ¸è¿›å¼æ¼”è¿›

1. **Phase 1**ï¼š**eBPF ç½‘ç»œæ¢é’ˆ**ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼Œæ ¸å¿ƒæŠ¤åŸæ²³ï¼‰
2. **Phase 2**ï¼šè§„åˆ™å¼•æ“å’Œåœºæ™¯åŒ–åˆ†æ
3. **Phase 3**ï¼šå¤„ç†è¿½è¸ªå’Œ Prometheus Exporter

## ğŸ“ æ€»ç»“

æ ¹å› åˆ†æç³»ç»ŸäºŒæœŸçš„è®¾è®¡å¯¹ xctl æœ‰å¾ˆé«˜çš„å‚è€ƒä»·å€¼ï¼Œç‰¹åˆ«æ˜¯ï¼š

1. **çŸ¥è¯†åº“ç³»ç»Ÿ**ï¼šè¿™æ˜¯æœ€å…³é”®çš„æ”¹è¿›ï¼Œå¯ä»¥å¤§å¹…é™ä½æˆæœ¬å¹¶æå‡å‡†ç¡®ç‡
2. **åœºæ™¯åŒ–åˆ†æ**ï¼šå¯ä»¥æå‡åˆ†æçš„ç²¾å‡†åº¦å’Œé’ˆå¯¹æ€§
3. **å¤„ç†è¿½è¸ª**ï¼šå¯ä»¥å½¢æˆå®Œæ•´çš„é—­ç¯ç®¡ç†
4. **é‡åŒ–æŒ‡æ ‡**ï¼šå¯ä»¥æ•°æ®åŒ–æ”¯æ’‘ç³»ç»Ÿæ”¹è¿›

å»ºè®®æŒ‰ç…§ä¸Šè¿°è·¯çº¿å›¾é€æ­¥å®æ–½ï¼Œä¿æŒ xctl çš„æç®€ä¸»ä¹‰è®¾è®¡å“²å­¦ï¼ŒåŒæ—¶è·å¾—è¿™äº›èƒ½åŠ›çš„æå‡ã€‚
